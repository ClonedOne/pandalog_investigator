From worker_analyzer

# terminating_all = terminates_all(filename)
# sleeping_all = calls_sleep_on_all(filename)
# crashing_all = is_crashing_all(filename)
# error_all = is_raising_error_all(filename)
# writes_file = writes_at_least_one_file(filename)
# file_utils.output_on_file_instructions(
#     filename,
#     process_dict,
#     inverted_process_dict,
#     dir_analyzed_logs,
#     db_file_malware_dict,
#     file_corrupted_processes_dict,
#     terminating_all,
#     sleeping_all,
#     crashing_all,
#     error_all,
#     writes_file
# )


def calls_sleep_all(filename):
    """
    Checks if the malware_objects associated with the filename have called the
    sleep function on all their processes.

    :param filename:
    :return: True if all processes called sleep, else False
    """
    all_pids = set()
    all_sleep = set()
    if filename in db_file_malware_dict:
        malware = db_file_malware_dict[filename]
        pid_list = malware.get_pid_list()
        malware_name = malware.get_name()
        for pid in pid_list:
            all_pids.add((malware_name, pid))
            sleep_count = malware.get_sleep(pid)
            if sleep_count:
                all_sleep.add((malware_name, pid))

    if filename in file_corrupted_processes_dict:
        malwares = file_corrupted_processes_dict[filename]
        for malware in malwares:
            malware_name = malware.get_name()
            pid_list = malware.get_pid_list()
            for pid in pid_list:
                all_pids.add((malware_name, pid))
                sleep_count = malware.get_sleep(pid)
                if sleep_count:
                    all_sleep.add((malware_name, pid))

    not_empty = len(all_pids) > 0
    if all_pids.issubset(all_sleep) and not_empty:
        file_sleep_dict[filename] = True
        return True
    else:
        file_sleep_dict[filename] = False
        return False


def terminates_all(filename):
    """
    Checks if the malware_objects associated with the filename have terminated
    all their processes.

    :param filename:
    :return: True if all processes terminated, else False
    """
    all_pids = set()
    all_term = set()
    if filename in db_file_malware_dict:
        malware = db_file_malware_dict[filename]
        malware_name = malware.get_name()
        pid_list = malware.get_pid_list()
        for pid in pid_list:
            all_pids.add((malware_name, pid))
            terms = malware.get_terminated_processes(pid)
            for term in terms:
                all_term.add((term[1], term[0]))

    if filename in file_corrupted_processes_dict:
        malwares = file_corrupted_processes_dict[filename]
        for malware in malwares:
            malware_name = malware.get_name()
            pid_list = malware.get_pid_list()
            for pid in pid_list:
                all_pids.add((malware_name, pid))
                terms = malware.get_terminated_processes(pid)
                for term in terms:
                    all_term.add((term[1], term[0]))

    not_empty = len(all_pids) > 0
    if all_pids.issubset(all_term) and not_empty:
        file_terminate_dict[filename] = True
        return True
    else:
        file_terminate_dict[filename] = False
        return False


def writes_at_least_one_file(filename):
    """
    Checks if the malware_objects associated with the filename have written
    at least one file in all their processes.

    :param filename:
    :return:
    """
    if filename in db_file_malware_dict:
        malware = db_file_malware_dict[filename]
        pid_list = malware.get_pid_list()
        for pid in pid_list:
            if malware.get_written_files(pid):
                file_writefile_dict[filename] = True
                return True
    if filename in file_corrupted_processes_dict:
        malwares = file_corrupted_processes_dict[filename]
        for malware in malwares:
            pid_list = malware.get_pid_list()
            for pid in pid_list:
                if malware.get_written_files(pid):
                    file_writefile_dict[filename] = True
                    return True

    file_writefile_dict[filename] = False
    return False


def is_crashing_all(filename):
    """
    Checks if the malware_objects associated with the filename have crashed all
    their processes.

    :param filename:
    :return: True if all processes have creshed, else False
    """
    all_pids = set()
    all_crash = set()
    if filename in db_file_malware_dict:
        malware = db_file_malware_dict[filename]
        malware_name = malware.get_name()
        pid_list = malware.get_pid_list()
        for pid in pid_list:
            all_pids.add((malware_name, pid))
            crash_count = malware.get_crash(pid)
            if crash_count:
                all_crash.add((malware_name, pid))

    if filename in file_corrupted_processes_dict:
        malwares = file_corrupted_processes_dict[filename]
        for malware in malwares:
            malware_name = malware.get_name()
            pid_list = malware.get_pid_list()
            for pid in pid_list:
                all_pids.add((malware_name, pid))
                crash_count = malware.get_crash(pid)
                if crash_count:
                    all_crash.add((malware_name, pid))

    not_empty = len(all_pids) > 0
    if all_pids.issubset(all_crash) and not_empty:
        file_crash_dict[filename] = True
        return True
    else:
        file_crash_dict[filename] = False
        return False


def is_raising_error_all(filename):
    """
    Checks if the malware_objects associated with the filename have raised hard
    errors for all their processes.

    :param filename:
    :return: True if all processes have raised errors, else False
    """
    all_pids = set()
    all_error = set()
    if filename in db_file_malware_dict:
        malware = db_file_malware_dict[filename]
        malware_name = malware.get_name()
        pid_list = malware.get_pid_list()
        for pid in pid_list:
            all_pids.add((malware_name, pid))
            error_count = malware.get_error(pid)
            if error_count:
                all_error.add((malware_name, pid))

    if filename in file_corrupted_processes_dict:
        malwares = file_corrupted_processes_dict[filename]
        for malware in malwares:
            malware_name = malware.get_name()
            pid_list = malware.get_pid_list()
            for pid in pid_list:
                all_pids.add((malware_name, pid))
                error_count = malware.get_error(pid)
                if error_count:
                    all_error.add((malware_name, pid))

    not_empty = len(all_pids) > 0
    if all_pids.issubset(all_error) and not_empty:
        file_error_dict[filename] = True
        return True
    else:
        file_error_dict[filename] = False
        return False






From log_analyzer

    db_file_malware_dict = {}
    file_corrupted_processes_dict = {}
    file_terminate_dict = {}
    file_sleep_dict = {}
    file_crash_dict = {}
    file_error_dict = {}
    file_writefile_dict = {}
    dict_list = [db_file_malware_dict,
                 file_corrupted_processes_dict,
                 file_terminate_dict,
                 file_sleep_dict,
                 file_crash_dict,
                 file_error_dict,
                 file_writefile_dict]
    utils.update_results(results, dict_list)

    file_utils.final_output_instructions(
        dir_results_path,
        filenames,
        db_file_malware_dict,
        file_corrupted_processes_dict,
        file_terminate_dict,
        file_sleep_dict,
        file_crash_dict,
        file_error_dict,
        file_writefile_dict
    )




From file_output

def output_on_file_instructions(filename, process_dict, inverted_process_dict, dir_analyzed_logs, db_file_malware_dict,
                                file_corrupted_processes_dict, terminating_all, sleeping_all, crashing_all,
                                error_all, writes_file):
    """
    Output on file the analyzed content of one log file. For each malware object related to the specified file name
    it prints the content of each malware pid and sums up the executed instructions. The instruction count is divided
    into 4 separated parts: from_db, created, memory_written and total. Each of these counters consider only the
    instructions executed by pids whose origin corresponds to the specified one.

    :param filename:
    :param process_dict:
    :param inverted_process_dict:
    :param dir_analyzed_logs:
    :param db_file_malware_dict:
    :param file_corrupted_processes_dict:
    :param terminating_all:
    :param sleeping_all:
    :param crashing_all:
    :param error_all:
    :param writes_file:
    :return:
    """
    with open(path.join(dir_analyzed_logs, filename), 'w', encoding='utf-8', errors='replace') as outfile:
        total_instructions = [0, 0, 0, 0]
        pprint.pprint(process_dict, outfile)
        outfile.write('\n')
        pprint.pprint(inverted_process_dict, outfile)
        outfile.write('\n')

        if filename in db_file_malware_dict:
            malware = db_file_malware_dict[filename]
            total_instructions = [sum(x) for x in zip(total_instructions, malware.get_total_executed_instructions())]
            outfile.write(domain_utils.repr_malware(malware) + '\n\n')

        if filename in file_corrupted_processes_dict:
            for malware in file_corrupted_processes_dict[filename]:
                total_instructions = [sum(x) for x in
                                      zip(total_instructions, malware.get_total_executed_instructions())]
                outfile.write(domain_utils.repr_malware(malware) + '\n\n')

        outfile.write('{} {}\n'.format(string_utils.instruction_final, total_instructions))

        outfile.write('{} {} {} {} {} {} {} {} {} {}\n'.format(
            string_utils.instruction_terminating,
            terminating_all,
            string_utils.instruction_sleeping,
            sleeping_all,
            string_utils.instruction_crashing,
            crashing_all,
            string_utils.instruction_raising_error,
            error_all,
            string_utils.instruction_writes_file,
            writes_file
        ))


def final_output_instructions(dir_results_path, filenames, db_file_malware_dict, file_corrupted_processes_dict,
                              file_terminate_dict, file_sleep_dict, file_crash_dict, file_error_dict,
                              file_writefile_dict):
    """
    Prints the final output on file. The final output contains aggregate data regarding the totality of the analyzed
    logs. For each filename and each malware_object associated sums up the instruction for each pid, checks if each
    pid has been terminated and if each pid has called the sleep function.

    :param dir_results_path: path to the result folder
    :param filenames:
    :param db_file_malware_dict:
    :param file_corrupted_processes_dict:
    :param file_terminate_dict:
    :param file_sleep_dict:
    :param file_crash_dict:
    :param file_error_dict:
    :param file_writefile_dict:
    :return:
    """
    with open(dir_results_path + '/corrupted_processes.txt', 'w', encoding='utf-8', errors='replace') as cp_file:
        with open(dir_results_path + '/analysis.txt', 'w', encoding='utf-8', errors='replace') as res_file:
            for filename in filenames:
                total_instructions = [0, 0, 0, 0]

                res_file.write('{} {}\n'.format(string_utils.filename, filename))
                cp_file.write('{} {}\n'.format(string_utils.filename, filename))

                if filename in db_file_malware_dict:
                    entry = db_file_malware_dict[filename]
                    total_instructions = [sum(x) for x in
                                          zip(total_instructions, entry.get_total_executed_instructions())]
                    cp_file.write(domain_utils.repr_malware_processes(entry))

                if filename in file_corrupted_processes_dict:
                    for entry in file_corrupted_processes_dict[filename]:
                        total_instructions = [sum(x) for x in
                                              zip(total_instructions, entry.get_total_executed_instructions())]
                        cp_file.write(domain_utils.repr_malware_processes(entry))

                res_file.write(
                    string_utils.out_final + '\t' +
                    str(total_instructions) + '\n'
                )
                res_file.write(
                    string_utils.out_terminating + '\t' +
                    (str(file_terminate_dict[filename]) if filename in file_terminate_dict else str(False)) +
                    '\t'
                )
                res_file.write(
                    string_utils.out_sleeping + '\t' +
                    (str(file_sleep_dict[filename]) if filename in file_sleep_dict else str(False)) +
                    '\t'
                )
                res_file.write(
                    string_utils.out_crashing + '\t' +
                    (str(file_crash_dict[filename]) if filename in file_crash_dict else str(False)) +
                    '\t'
                )
                res_file.write(
                    string_utils.out_raising_error + '\t' +
                    (str(file_error_dict[filename]) if filename in file_error_dict else str(False)) +
                    '\t'
                )
                res_file.write(
                    string_utils.out_writes_file + '\t' +
                    (str(file_writefile_dict[filename]) if filename in file_writefile_dict else str(False)) +
                    '\n\n'
                )
                cp_file.write('\n\n')






From domain_utils


def repr_malware(malware):
    """
    Returns a string representation of the specified malware object.

    :param malware:
    :return: string representing the whole malware
    """
    result = ''
    for pid in malware.get_pid_list():
        result += '{}\t{}\n'.format(string_utils.proc_name, malware.name)
        result += '{}\t{}\n'.format(string_utils.proc_pid, pid)
        result += '{}\t{}\n'.format(string_utils.proc_orig, malware.get_origin(pid))
        result += '{}\t{}\n'.format(string_utils.last_inst, malware.get_starting_instruction(pid))
        result += '{}\t{}\n'.format(string_utils.exec_inst, malware.get_instruction_executed(pid))
        result += '{}\t{}\n'.format(string_utils.text_sleep, malware.get_sleep(pid))

        result += '\n{}\n'.format(string_utils.text_spawned)
        result += '| {:20s} | {:20s} | {:20s} | {:20s} |\n'.format(
            'New pid',
            'Process name',
            'Instruction',
            'Executable path'
        )
        for entry in malware.get_spawned_processes(pid):
            for sub_entry in entry:
                result += '| {:20s} '.format(str(sub_entry))
            result += '|\n'

        result += '\n{}\n'.format(string_utils.text_terminated)
        result += '| {:20s} | {:20s} | {:20s} |\n'.format(
            'Terminated pid',
            'Process name',
            'Instruction'
        )
        for entry in malware.get_terminated_processes(pid):
            for sub_entry in entry:
                result += '| {:20s} '.format(str(sub_entry))
            result += '|\n'

        result += '\n{}\n'.format(string_utils.text_written)
        result += '| {:20s} | {:20s} | {:20s} |\n'.format(
            'Written pid',
            'Process name',
            'Instruction'
        )
        for entry in malware.get_written_memories(pid):
            for sub_entry in entry:
                result += '| {:20s} '.format(str(sub_entry))
            result += '|\n'

        result += '\n{}\n'.format(string_utils.text_spec_status)
        result += '| {:20s} | {:20s} | {:20s} |\n'.format(
            string_utils.text_crash,
            string_utils.text_raise_err,
            string_utils.text_written_file
        )
        result += '| {:20s} | {:20s} | {:20s} |\n\n'.format(
            str(malware.get_crash(pid)),
            str(malware.get_error(pid)),
            str(malware.get_written_files(pid))
        )

    executed = malware.get_total_executed_instructions()
    result += string_utils.text_executed + '\n'
    result += '| {:15s} | {:15s} | {:15s} | {:15s} |\n'.format('DB', 'created', 'memory written', 'total')
    result += '| {:15d} | {:15d} | {:15d} | {:15d} |\n\n\n'.format(executed[0], executed[1], executed[2], executed[3])
    return result
import logging


logger = logging.getLogger(__name__)


class Malware:

    FROM_DB = 'database'
    CREATED = 'created'
    WRITTEN = 'mem_written'
    origins = [FROM_DB, CREATED, WRITTEN]

    def __init__(self, name):
        self.name = name
        self.pid_list = []
        self.instruction_executed = {}
        self.starting_instruction = {}
        self.active_pid = {}
        self.spawned_processes = {}
        self.terminated_processes = {}
        self.sleep = {}
        self.written_memory = {}
        self.origin = {}
        self.crashing = {}
        self.error = {}
        self.parent = {}
        self.written_file = {}

    # Condition checking methods

    def is_valid_pid(self, pid):
        if pid in self.pid_list:
            return True
        else:
            return False

    def has_active_pid(self):
        for pid in self.pid_list:
            if self.active_pid[pid]:
                return True
        return False

    def is_active_pid(self, pid):
        if pid not in self.active_pid:
            logger.error('ERROR is_pid_active pid not found')
            return -1
        return self.active_pid[pid]

    # Setter methods

    def add_pid(self, pid, origin, parent):
        if pid in self.pid_list:
            logger.error('ERROR add_pid pid already in the list')
            return -1
        elif origin not in self.origins:
            logger.error('ERROR add_pid specified origin not valid')
            return -1
        else:
            self.pid_list.append(pid)
            self.instruction_executed[pid] = 0
            self.starting_instruction[pid] = 0
            self.active_pid[pid] = False
            self.spawned_processes[pid] = []
            self.terminated_processes[pid] = []
            self.written_memory[pid] = []
            self.origin[pid] = origin
            self.sleep[pid] = 0
            self.crashing[pid] = False
            self.error[pid] = False
            self.parent[pid] = parent
            self.written_file[pid] = False
            return 1

    def update_starting_instruction(self, pid, starting_instruction):
        if pid not in self.starting_instruction:
            logger.error("ERROR update_starting_instruction pid not found ")
            return -1
        self.starting_instruction[pid] = starting_instruction
        return 1

    def add_instruction_executed(self, pid, instruction_executed):
        if pid not in self.instruction_executed:
            logger.error("ERROR add_instruction_executed pid not found ")
            return -1
        self.instruction_executed[pid] += instruction_executed
        return 1

    def add_spawned_process(self, pid, new_pid, new_process_name, instruction, path):
        if pid not in self.spawned_processes:
            logger.error('ERROR add_spawned_process pid not found')
            return -1
        self.spawned_processes[pid].append((new_pid, new_process_name, instruction, path))
        return 1

    def add_terminated_process(self, pid, terminated_pid, terminated_process_name, instruction):
        if pid not in self.terminated_processes:
            logger.error('ERROR add_terminated_process pid not found')
            return -1
        self.terminated_processes[pid].append((terminated_pid, terminated_process_name, instruction))
        return 1

    def add_written_memory(self, pid, written_pid, written_process_name, instruction):
        if pid not in self.written_memory:
            logger.error('ERROR add_written_memory pid not found')
            return -1
        self.written_memory[pid].append((written_pid, written_process_name, instruction))
        return 1

    def add_sleep(self, pid):
        if pid not in self.sleep:
            logger.error('ERROR add_sleep pid not found')
            return -1
        self.sleep[pid] += 1
        return 1

    def add_crash(self, pid):
        if pid not in self.crashing:
            logger.error('ERROR add_crash pid not found')
            return -1
        self.crashing[pid] = True
        return 1

    def add_error(self, pid):
        if pid not in self.error:
            logger.error('ERROR add_error pid not found')
            return -1
        self.error[pid] = True
        return 1

    def add_written_file(self, pid):
        if pid not in self.written_file:
            logger.error('ERROR add_written_file pid not found')
            return -1
        self.written_file[pid] = True
        return 1

    # Getter methods

    def get_name(self):
        return self.name

    def get_active_pid(self):
        for pid, active in self.active_pid.items():
            if active:
                return pid
        logger.error('ERROR get_active_pid active pid not found')
        return -1

    def get_pid_list(self):
        return self.pid_list

    def get_starting_instruction(self, pid):
        if pid not in self.starting_instruction:
            logger.error("ERROR get_starting_instruction pid not found")
            return -1
        return self.starting_instruction[pid]

    def get_instruction_executed(self, pid):
        if pid not in self.instruction_executed:
            logger.error("ERROR get_instruction_executed pid not found")
            return -1
        return self.instruction_executed[pid]

    def get_spawned_processes(self, pid):
        if pid not in self.spawned_processes:
            logger.error('ERROR get_spawned_processes pid not found')
            return -1
        return self.spawned_processes[pid]

    def get_terminated_processes(self, pid):
        if pid not in self.terminated_processes:
            logger.error('ERROR get_terminated_processes pid not found')
            return -1
        return self.terminated_processes[pid]

    def get_written_memories(self, pid):
        if pid not in self.written_memory:
            logger.error('ERROR get_written_memories pid not found')
            return -1
        return self.written_memory[pid]

    def get_sleep(self, pid):
        if pid not in self.sleep:
            logger.error('ERROR get_sleep pid not found')
            return -1
        return self.sleep[pid]

    def get_origin(self, pid):
        if pid not in self.origin:
            logger.error('ERROR get_origin pid not found')
            return -1
        return self.origin[pid]

    def get_crash(self, pid):
        if pid not in self.crashing:
            logger.error('ERROR get_crash pid not found')
            return -1
        return self.crashing[pid]

    def get_error(self, pid):
        if pid not in self.error:
            logger.error('ERROR get_error pid not found')
            return -1
        return self.error[pid]

    def get_parent_of(self, pid):
        if pid not in self.parent:
            logger.error('ERROR get_parent_of pid not found')
            return -1
        return self.parent[pid]

    def get_total_executed_instructions(self):
        executed_db = 0
        executed_created = 0
        executed_written = 0
        executed_tot = 0
        for pid in self.pid_list:
            delta = self.get_instruction_executed(pid)
            if self.origin[pid] == self.FROM_DB:
                executed_db += delta
            elif self.origin[pid] == self.CREATED:
                executed_created += delta
            else:
                executed_written += delta
            executed_tot += delta
        return executed_db, executed_created, executed_written, executed_tot

    def get_written_files(self, pid):
        if pid not in self.written_file:
            logger.error('ERROR get_written_files pid not found')
            return -1
        return self.written_file[pid]

    # Action methods

    def activate_pid(self, pid):
        if pid not in self.active_pid:
            logger.error('ERROR set_active_pid pid not found')
            return -1
        self.active_pid[pid] = True

    def deactivate_pid(self, pid):
        if pid not in self.active_pid:
            logger.error('ERROR deactivate_pid pid not found')
            return -1
        self.active_pid[pid] = False

class Malware:

    FROM_DB = 'From database'
    CREATED = 'Created process'
    WRITTEN = 'Memory written process'
    origins = [FROM_DB, CREATED, WRITTEN]

    def __init__(self, name):
        self.name = name
        self.pid_list = []
        self.instruction_executed = {}
        self.starting_instruction = {}
        self.active_pid = {}
        self.spawned_processes = {}
        self.terminated_processes = {}
        self.sleep = {}
        self.written_memory = {}
        self.origin = {}

    def is_valid_pid(self, pid):
        if pid in self.pid_list:
            return True
        else:
            return False

    def add_pid(self, pid, origin):
        if pid in self.pid_list:
            print 'ERROR add_pid pid already in the list'
            return -1
        elif origin not in self.origins:
            print 'ERROR add_pid specified origin not valid'
            return -1
        else:
            self.pid_list.append(pid)
            self.instruction_executed[pid] = 0
            self.starting_instruction[pid] = 0
            self.active_pid[pid] = False
            self.spawned_processes[pid] = []
            self.terminated_processes[pid] = []
            self.written_memory[pid] = []
            self.origin[pid] = origin
            self.sleep[pid] = []
            return 1

    def get_active_pid(self):
        for pid, active in self.active_pid.iteritems():
            if active:
                return pid
        print 'ERROR get_active_pid active pid not found'
        return -1

    def has_active_pid(self):
        for pid in self.pid_list:
            if self.active_pid[pid]:
                return True
        return False

    def set_active_pid(self, pid):
        if pid not in self.active_pid:
            print 'ERROR set_active_pid pid not found'
            return -1
        self.active_pid[pid] = True

    def deactivate_pid(self, pid):
        if pid not in self.active_pid:
            print 'ERROR deactivate_pid pid not found'
            return -1
        self.active_pid[pid] = False

    def is_pid_active(self, pid):
        if pid not in self.active_pid:
            print 'ERROR is_pid_active pid not found'
            return -1
        return self.active_pid[pid]

    def get_pid_list(self):
        return self.pid_list

    def get_name(self):
        return self.name

    def update_starting_instruction(self, pid, starting_instruction):
        if pid not in self.starting_instruction:
            print "ERROR update_starting_instruction pid not found "
            return -1
        self.starting_instruction[pid] = starting_instruction
        return 1

    def get_starting_instruction(self, pid):
        if pid not in self.starting_instruction:
            print "ERROR get_starting_instruction pid not found"
            return -1
        return self.starting_instruction[pid]

    def add_instruction_executed(self, pid, instruction_executed):
        if pid not in self.instruction_executed:
            print "ERROR add_instruction_executed pid not found "
            return -1
        self.instruction_executed[pid] += instruction_executed
        return 1

    def get_instruction_executed(self, pid):
        if pid not in self.instruction_executed:
            print "ERROR get_instruction_executed pid not found"
            return -1
        return self.instruction_executed[pid]

    def add_spawned_process(self, pid, new_pid, new_process_name, instruction, path):
        if pid not in self.spawned_processes:
            print 'ERROR add_spawned_process pid not found'
            return -1
        self.spawned_processes[pid].append((new_pid, new_process_name, instruction, path))
        return 1

    def get_spawned_processes(self, pid):
        if pid not in self.spawned_processes:
            print 'ERROR get_spawned_processes pid not found'
            return -1
        return self.spawned_processes[pid]

    def add_terminated_process(self, pid, terminated_pid, terminated_process_name, instruction):
        if pid not in self.terminated_processes:
            print 'ERROR add_terminated_process pid not found'
            return -1
        self.terminated_processes[pid].append((terminated_pid, terminated_process_name, instruction))
        return 1

    def get_terminated_processes(self, pid):
        if pid not in self.terminated_processes:
            print 'ERROR get_terminated_processes pid not found'
            return -1
        return self.terminated_processes[pid]

    def add_written_memory(self, pid, written_pid, written_process_name, instruction):
        if pid not in self.written_memory:
            print 'ERROR add_written_memory pid not found'
            return -1
        self.written_memory[pid].append((written_pid, written_process_name, instruction))
        return 1

    def get_written_memories(self, pid):
        if pid not in self.written_memory:
            print 'ERROR get_written_memories pid not found'
            return -1
        return self.written_memory[pid]

    def add_sleep(self, pid, instruction):
        if pid not in self.sleep:
            print 'ERROR add_sleep pid not found'
            return -1
        self.sleep[pid].append(instruction)

    def get_sleep(self, pid):
        if pid not in self.sleep:
            print 'ERROR get_sleep pid not found'
            return -1
        return self.sleep[pid]

    def get_origin(self, pid):
        if pid not in self.origin:
            print 'ERROR get_origin pid not found'
            return -1
        return self.origin[pid]

    def get_total_executed_instructions(self):
        executed_db = 0
        executed_created = 0
        executed_written = 0
        executed_tot = 0
        for pid in self.pid_list:
            delta = self.get_instruction_executed(pid)
            if self.origin[pid] == self.FROM_DB:
                executed_db += delta
            elif self.origin[pid] == self.CREATED:
                executed_created += delta
            else:
                executed_written += delta
            executed_tot += delta
        return executed_db, executed_created, executed_written, executed_tot

    def __str__(self):

        string_spawned = '\nSpawned processes: new pid | process name | instruction | executable path\n'
        string_terminated = '\nTerminated processes: terminated pid | terminated process name | instruction\n'
        string_written = '\nMemory written: written pid | written process name | instruction \n'
        string_sleep = '\nNtDelayExecution called: instruction\n'
        string_executed = '\nInstructions executed by all pids: DB | created | memory written | total\n'

        result = 'Malware name: ' + self.name + '\n'
        for i in self.pid_list:
            result += '\nMalware pid: ' + str(i) + '\t' + self.origin[i] + '\n' \
                      + 'Last starting instruction: ' + str(self.get_starting_instruction(i)) + '\n' \
                      + 'Instruction executed: ' + str(self.get_instruction_executed(i)) + '\n'

            result += string_spawned
            for entry in self.get_spawned_processes(i):
                for sub_entry in entry:
                    result += str(sub_entry) + '\t'
                result += '\n'

            result += string_terminated
            for entry in self.get_terminated_processes(i):
                for sub_entry in entry:
                    result += str(sub_entry) + '\t'
                result += '\n'

            result += string_written
            for entry in self.get_written_memories(i):
                for sub_entry in entry:
                    result += str(sub_entry) + '\t'
                result += '\n'

            result += string_sleep
            for entry in self.get_sleep(i):
                result += str(entry)
                result += '\n'

        result += string_executed
        executed = self.get_total_executed_instructions()
        result += str(executed[0]) + '\t' + str(executed[1]) + '\t' + str(executed[2]) + '\t' + str(executed[3]) + '\n'

        return result

    __repr__ = __str__

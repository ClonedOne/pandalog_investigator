class Malware:

    def __init__(self, name):
        self.name = name
        self.pid_list = []
        self.instruction_executed = {}
        self.starting_instruction = {}
        self.active_pid = {}
        self.spawned_processes = {}
        self.terminated_processes = {}
        self.written_memory = {}

    def is_valid_pid(self, pid):
        if pid in self.pid_list:
            return True
        else:
            return False

    def add_pid(self, pid):
        if pid in self.pid_list:
            print 'ERROR add_pid pid already in the list'
            return -1
        else:
            self.pid_list.append(pid)
            self.instruction_executed[pid] = 0
            self.starting_instruction[pid] = 0
            self.active_pid[pid] = False
            self.spawned_processes[pid] = []
            self.terminated_processes[pid] = []
            self.written_memory[pid] = []
            return 1

    def get_active_pid(self):
        for pid, active in self.active_pid.iteritems():
            if active:
                return pid
        print 'ERROR get_active_pid active pid not found'
        return -1

    def has_active_pid(self):
        for pid in self.pid_list:
            if self.active_pid[pid]:
                return True
        return False

    def set_active_pid(self, pid):
        if pid not in self.active_pid:
            print 'ERROR set_active_pid pid not found'
            return -1
        self.active_pid[pid] = True

    def deactivate_pid(self, pid):
        if pid not in self.active_pid:
            print 'ERROR deactivate_pid pid not found'
            return -1
        self.active_pid[pid] = False

    def is_pid_active(self, pid):
        if pid not in self.active_pid:
            print 'ERROR is_pid_active pid not found'
            return -1
        return self.active_pid[pid]

    def get_pid_list(self):
        return self.pid_list

    def get_name(self):
        return self.name

    def update_starting_instruction(self, pid, starting_instruction):
        if pid not in self.starting_instruction:
            print "ERROR update_starting_instruction pid not found "
            return -1
        self.starting_instruction[pid] = starting_instruction
        return 1

    def get_starting_instruction(self, pid):
        if pid not in self.starting_instruction:
            print "ERROR get_starting_instruction pid not found"
            return -1
        return self.starting_instruction[pid]

    def add_instruction_executed(self, pid, instruction_executed):
        if pid not in self.instruction_executed:
            print "ERROR add_instruction_executed pid not found "
            return -1
        self.instruction_executed[pid] += instruction_executed
        return 1

    def get_instruction_executed(self, pid):
        if pid not in self.instruction_executed:
            print "ERROR get_instruction_executed pid not found"
            return -1
        return self.instruction_executed[pid]

    def add_spawned_process(self, pid, new_pid, new_process_name, instruction, path):
        if pid not in self.spawned_processes:
            print 'ERROR add_spawned_process pid not found'
            return -1
        self.spawned_processes[pid].append((new_pid, new_process_name, instruction, path))
        return 1

    def get_spawned_processes(self, pid):
        if pid not in self.spawned_processes:
            print 'ERROR get_spawned_processes pid not found'
            return -1
        return self.spawned_processes[pid]

    def add_terminated_process(self, pid, terminated_pid, terminated_process_name, instruction):
        if pid not in self.terminated_processes:
            print 'ERROR add_terminated_process pid not found'
            return -1
        self.terminated_processes[pid].append((terminated_pid, terminated_process_name, instruction))
        return 1

    def get_terminated_processes(self, pid):
        if pid not in self.terminated_processes:
            print 'ERROR get_terminated_processes pid not found'
            return -1
        return self.terminated_processes[pid]

    def add_written_memory(self, pid, written_pid, written_process_name, instruction):
        if pid not in self.written_memory:
            print 'ERROR add_written_memory pid not found'
            return -1
        self.written_memory[pid].append((written_pid, written_process_name, instruction))
        return 1

    def get_written_memories(self, pid):
        if pid not in self.written_memory:
            print 'ERROR get_written_memories pid not found'
            return -1
        return self.written_memory[pid]

    def get_total_executed_instructions(self):
        executed = 0
        for pid in self.pid_list:
            executed += self.get_instruction_executed(pid)
        return executed

    def __str__(self):

        string_spawned = '\nSpawned processes: new pid | process name | instruction | executable path\n'
        string_terminated = '\nTerminated processes: terminated pid | terminated process name | instruction\n'
        string_written = '\nMemory written: written pid | written process name | instruction \n'
        string_executed = '\nTotal instruction executed by all malware\'s processes: \t'

        result = 'Malware name: ' + self.name + '\n'
        for i in self.pid_list:
            result += '\nMalware pid: ' + str(i) + '\n' \
                      + 'Last starting instruction: ' + str(self.get_starting_instruction(i)) + '\n' \
                      + 'Instruction executed: ' + str(self.get_instruction_executed(i)) + '\n'

            result += string_spawned
            for entry in self.get_spawned_processes(i):
                for sub_entry in entry:
                    result += str(sub_entry) + '\t'
                result += '\n'

            result += string_terminated
            for entry in self.get_terminated_processes(i):
                for sub_entry in entry:
                    result += str(sub_entry) + '\t'
                result += '\n'

            result += string_written
            for entry in self.get_written_memories(i):
                for sub_entry in entry:
                    result += str(sub_entry) + '\t'
                result += '\n'

        result += string_executed
        result += str(self.get_total_executed_instructions()) + '\n'

        return result

    __repr__ = __str__
